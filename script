#!/bin/bash
#backgroundOnly=true
#arrayStarted=true

# v1.0.0 - 2018/03/17

#### DISCLAIMER ####
# Use at your own risk. This is a work-in-progress and provided as is.
# I have tested this on my own server, as best as I am able, but YMMV.
# -jtok


# what is the scripts' official name.
official_script_name="script"

# set the name of the script to a variable so it can be used.
me=`basename "$0"`


# this script takes a btrfs snapshot and copies it to a specified location.

################################################## script variables start ######################################################

# default 0 but set the master switch to 1 if you want to enable the script otherwise it will not run.
enabled="0"

# location for snapshots. must be local btrfs volume.
snapshot_location="/mnt/user/share/snapshot_folder/"

# backup location to copy snapshots.
backup_location="/mnt/user/share/backup_folder/"

# default is 0. but set to 1 if the backup location on a btrfs volume.
backup_btrfs_volume="0"

# list of folders that will be skipped when copying snapshot. WARNING: any folder with this name will be skipped along with its subfolders.
folders_to_skip="
folder1
folder2
"

# default is 0. set this to the number of days backups should be kept. 0 means indefinitely.
number_of_days_to_keep_backups="0"

# default is 0. set this to the number of backups that should be kept. 0 means infinitely.
number_of_backups_to_keep="0"

# default is 0. set this to 1 if you would like to compress backups. This can add a significant amount of time to the backup process. uses tar.gz for sparse file compatibility.
# WARNING: do not turn on if you already have uncompressed backups. You will need to move or delete uncompressed backups before using. this will compress all .xml, .img, and .qcow2 images in the backup directory into ONE tarball.
compress_backups="0"

# default is 1. set this to 0 if you would like to have backups without a timestamp. Timestamps are dropped only when number_of_backups_to_keep is equal to 1.
timestamp_files="1"


#### advanced variables ####

# default is 0. set this to 1 to compare files after copy and run rsync in the event of failure. could add significant amount of time depending on the size of vms.
compare_files="0"

# default is 1. set to 0 if you would like to skip backing up xml configuration files.
backup_xml="1"

# default is 1. set to 0 if you would like to skip backing up vdisks. setting this to 0 will automatically disable compression.
backup_vdisks="1"

# default is 0. set this to 1 if you would like to start a vm after it has successfully been backed up. will override set_vm_to_original_state when set to 1.
start_vm_after_backup="0"

# default is 0. set this to 1 if you would like to start a vm after it has failed to have been backed up. will override set_vm_to_original_state when set to 1.
start_vm_after_failure="0"

# *CURRENTLY UNUSED* default is 1. set this to 0 if you would like to perform a dry-run backup.
actually_copy_files="1"

# default is 20. set this to the number of times you would like to check if a clean shutdown of a vm has been successfull.
clean_shutdown_checks="20"

# default is 30. set this to the number of seconds to wait in between checks to see if a clean shutdown has been successfull.
seconds_to_wait="30"

################################################## script variables end #########################################################


###################################################### script start #############################################################

# check the name of the script is as it should be. if yes, continue. if no, exit.
if [ "$me" == "$official_script_name" ]; then

	echo "information: official_script_name is $official_script_name. script name is valid. continuing."

elif [ ! "$me" == "$official_script_name" ]; then

	echo "failure: official_script_name is $official_script_name. script name is invalid. exiting."

	exit 1

fi


# check to see if the script has been enabled or disabled by the user. if yes, continue if no, exit. if input invalid, exit.
if [[ "$enabled" =~ ^(0|1)$ ]]; then

	if [ "$enabled" -eq 1 ]; then

		echo "information: enabled is $enabled. script is enabled. continuing."

	elif [ ! "$enabled" -eq 1 ]; then

		echo "failure: enabled is $enabled. script is disabled. exiting."

		exit 1

	fi

else

	echo "failure: enabled is $enabled. this is not a valid format. expecting [0 = no] or [1 = yes]. exiting."

	exit 1

fi


# check to see if the backup_location specified by the user exists. if yes, continue if no, exit. if exists check if writable, if yes continue, if not exit. if input invalid, exit.
if [ -d "$backup_location" ]; then

	echo "information: backup_location is $backup_location. this location exists. continuing."

	# if backup_location does exist check to see if the backup_location is writable.
	if [ -w "$backup_location" ]; then

		echo "information: backup_location is $backup_location. this location is writable. continuing."

	else

		echo "failure: backup_location is $backup_location. this location is not writable. exiting."

		exit 1

	fi

else

	echo "failure: backup_location is $backup_location. this location does not exist. exiting."

	exit 1

fi


# check to see if vm should be killed if clean shutdown fails. if yes, continue if no, continue. if input invalid, exit.
if [[ "$kill_vm_if_cant_shutdown" =~ ^(0|1)$ ]]; then

	if [ "$kill_vm_if_cant_shutdown" -eq 0 ]; then

		echo "warning: kill_vm_if_cant_shutdown is $kill_vm_if_cant_shutdown. vms will not be forced to shutdown if a clean shutdown can not be detected."

	elif [ "$kill_vm_if_cant_shutdown" -eq 1 ]; then

		echo "information: kill_vm_if_cant_shutdown is $kill_vm_if_cant_shutdown. vms will be forced to shutdown if a clean shutdown can not be detected."

	fi

else

	echo "failure: kill_vm_if_cant_shutdown is $kill_vm_if_cant_shutdown. this is not a valid format. expecting [0 = no] or [1 = yes]. exiting."

	exit 1

fi


# check to see if vm should be set to original state after backup. if yes, continue if no, continue. if input invalid, exit.
if [[ "$set_vm_to_original_state" =~ ^(0|1)$ ]]; then

	if [ "$set_vm_to_original_state" -eq 0 ]; then

		echo "warning: set_vm_to_original_state is $set_vm_to_original_state. vms will not be set to their original state after backup."

	elif [ "$set_vm_to_original_state" -eq 1 ]; then

		echo "information: set_vm_to_original_state is $set_vm_to_original_state. vms will be set to their original state after backup."

	fi

else

	echo "failure: set_vm_to_original_state is $set_vm_to_original_state. this is not a valid format. expecting [0 = no] or [1 = yes]. exiting."

	exit 1

fi


# check to how many days backups should be kept. if yes, continue if no, continue. if input invalid, exit.
if [[ "$number_of_days_to_keep_backups" =~ ^[0-9]+$ ]]; then

	if [ "$number_of_days_to_keep_backups" -lt 7 ]; then

		if [ "$number_of_days_to_keep_backups" -eq 0 ]; then

			echo "information: number_of_days_to_keep_backups is $number_of_days_to_keep_backups. backups will be kept indefinitely. be sure to set number_of_backups_to_keep to keep backups storage usage down."

		else

			echo "warning: number_of_days_to_keep_backups is $number_of_days_to_keep_backups. this is potentially an insufficient number of days to keep your backups."

		fi

	elif [ "$number_of_days_to_keep_backups" -gt 180 ]; then

		echo "warning: number_of_days_to_keep_backups is $number_of_days_to_keep_backups. this is a long time to keep your backups."

	elif [ "$number_of_days_to_keep_backups" -ge 5 -a "$number_of_days_to_keep_backups" -le 180 ]; then

		echo "information: number_of_days_to_keep_backups is $number_of_days_to_keep_backups. this is probably a sufficient number of days to keep your backups."

	fi

else

	echo "failure: number_of_days_to_keep_backups is $number_of_days_to_keep_backups. this is not a valid format. expecting a number between [0 - 1000000]. exiting."

	exit 1

fi


# check to how many backups should be kept. if yes, continue if no, continue. if input invalid, exit.
if [[ "$number_of_backups_to_keep" =~ ^[0-9]+$ ]]; then

	if [ "$number_of_backups_to_keep" -lt 2 ]; then

		if [ "$number_of_backups_to_keep" -eq 0 ]; then

			echo "information: number_of_backups_to_keep is $number_of_backups_to_keep. an infinite number of backups will be kept. be sure to set number_of_days_to_keep_backups to keep backups storage usage down."

		else

			echo "warning: number_of_backups_to_keep is $number_of_backups_to_keep. this is potentially an insufficient number of backups to keep."

		fi

	elif [ "$number_of_backups_to_keep" -gt 40 ]; then

		echo "warning: number_of_backups_to_keep is $number_of_backups_to_keep. this is a lot of backups to keep."

	elif [ "$number_of_backups_to_keep" -ge 2 -a "$number_of_backups_to_keep" -le 40 ]; then

		echo "information: number_of_backups_to_keep is $number_of_backups_to_keep. this is probably a sufficient number of backups to keep."

	fi

else

	echo "failure: number_of_backups_to_keep is $number_of_backups_to_keep. this is not a valid format. expecting a number between [0 - 1000000]. exiting."

	exit 1

fi


# check to see if backups should be compressed. if yes, continue if no, continue. if input invalid, exit.
if [[ "$compress_backups" =~ ^(0|1)$ ]]; then

	if [ "$compress_backups" -eq 0 ]; then

		echo "information: compress_backups is $compress_backups. backups will not be compressed."

	elif [ "$compress_backups" -eq 1 ]; then

		echo "information: compress_backups is $compress_backups. backups will be compressed."

	fi

else

	echo "failure: compress_backups is $compress_backups. this is not a valid format. expecting [0 = no] or [1 = yes]. exiting."

	exit 1

fi


# create timestamp variable for rolling backups.
timestamp=`date '+%Y%m%d_%H%M'`"_"

# check to see if backups should have timestamp. if yes, continue if no, continue. if input invalid, exit.
if [[ "$timestamp_files" =~ ^(0|1)$ ]]; then

	if [ "$timestamp_files" -eq 0 ]; then

		echo "information: timestamp_files is $timestamp_files. this variable is only used when number_of_backups_to_keep is set to 1. timestamp will not be added to backup files."

	elif  [ "$timestamp_files" -eq 1 ]; then

		echo "information: timestamp_files is $timestamp_files. timestamp will be added to backup files."

	fi

else

	echo "failure: timestamp_files is $timestamp_files. this is not a valid format. expecting [0 = no] or [1 = yes]. exiting."

	exit 1

fi


#### advanced variables ####

# check to see if files should be compared after backup. if yes, continue if no, continue. if input invalid, exit.
if [[ "$compare_files" =~ ^(0|1)$ ]]; then

	if [ "$compare_files" -eq 0 ]; then

		echo "information: compare_files is $compare_files. files will not be compared after backups."

	elif [ "$compare_files" -eq 1 ]; then

		echo "information: compare_files is $compare_files. files will be compared after backups."

	fi

else

	echo "failure: compare_files is $compare_files. this is not a valid format. expecting [0 = no] or [1 = yes]. exiting."

	exit 1

fi


# check to see if xml should be backed up. if yes, continue if no, continue. if input invalid, exit.
if [[ "$backup_xml" =~ ^(0|1)$ ]]; then

	if [ "$backup_xml" -eq 0 ]; then

		echo "warning: backup_xml is $backup_xml. vms will not have their xml configurations backed up."

	elif [ "$backup_xml" -eq 1 ]; then

		echo "information: backup_xml is $backup_xml. vms will have their xml configurations backed up."

	fi

else

	echo "failure: backup_xml is $backup_xml. this is not a valid format. expecting [0 = no] or [1 = yes]. exiting."

	exit 1

fi


# check to see if vdisks should be backed up. if yes, continue if no, continue. if input invalid, exit.
if [[ "$backup_vdisks" =~ ^(0|1)$ ]]; then

	if [ "$backup_vdisks" -eq 0 ]; then

		echo "warning: backup_vdisks is $backup_vdisks. vms will not have their vdisks backed up. compression will be set to off."

		compress_backups="0"

	elif [ "$backup_vdisks" -eq 1 ]; then

		echo "information: backup_vdisks is $backup_vdisks. vms will have their vdisks backed up."

	fi

else

	echo "failure: backup_vdisks is $backup_vdisks. this is not a valid format. expecting [0 = no] or [1 = yes]. exiting."

	exit 1

fi


# check to see if vms should be started after a successfull backup. if yes, continue if no, continue. if input invalid, exit.
if [[ "$start_vm_after_backup" =~ ^(0|1)$ ]]; then

	if [ "$start_vm_after_backup" -eq 0 ]; then

		echo "warning: start_vm_after_backup is $start_vm_after_backup. vms will not be started following successfull backup."

	elif [ "$start_vm_after_backup" -eq 1 ]; then

		echo "information: start_vm_after_backup is $start_vm_after_backup vms will be started following a successfull backup."

	fi

else

	echo "failure: start_vm_after_backup is $start_vm_after_backup. this is not a valid format. expecting [0 = no] or [1 = yes]. exiting."

	exit 1

fi


# check to see if vms should be started after an unsuccessfull backup. if yes, continue if no, continue. if input invalid, exit.
if [[ "$start_vm_after_failure" =~ ^(0|1)$ ]]; then

	if [ "$start_vm_after_failure" -eq 0 ]; then

		echo "warning: start_vm_after_failure is $start_vm_after_failure. vms will not be started following an unsuccessfull backup."

	elif [ "$start_vm_after_failure" -eq 1 ]; then

		echo "information: start_vm_after_failure is $start_vm_after_failure. vms will be started following an unsuccessfull backup."

	fi

else

	echo "failure: start_vm_after_failure is $start_vm_after_failure. this is not a valid format. expecting [0 = no] or [1 = yes]. exiting."

	exit 1

fi


# validate the actually_copy_files option. if yes the rsync command line option for dry-run. if input invalid, exit.
if [[ "$actually_copy_files" =~ ^(0|1)$ ]]; then

	if [ "$actually_copy_files" -eq 0 ]; then

		echo "information: actually_copy_files flag is 0. no files will be coppied."

		# create a variable which tells rsync to do a dry-run.
		rsync_dry_run_option="n"

	elif [ "$actually_copy_files" -eq 1 ]; then

		echo "warning: actually_copy_files is 1. files will be coppied."

	fi

else

	echo "failure: actually_copy_files is $actually_copy_files. this is not a valid format. expecting [0 = no] or [1 = yes]. exiting."

	exit 1

fi


# check to see how many times vm's state should be checked for shutdown. if yes, continue if no, continue if input invalid, exit.
if [[ "$clean_shutdown_checks" =~ ^[0-9]+$ ]]; then

	if [ "$clean_shutdown_checks" -lt 5 ]; then

		echo "warning: clean_shutdown_checks is $clean_shutdown_checks. this is potentially an insufficient number of shutdown checks."

	elif [ "$clean_shutdown_checks" -gt 50 ]; then

		echo "warning: clean_shutdown_checks is $clean_shutdown_checks. this is a vast number of shutdown checks."

	elif [ "$clean_shutdown_checks" -ge 5 -a "$clean_shutdown_checks" -le 50 ]; then

		echo "information: clean_shutdown_checks is $clean_shutdown_checks. this is probably a sufficient number of shutdown checks."

	fi

else

	echo "failure: clean_shutdown_checks is $clean_shutdown_checks. this is not a valid format. expecting a number between [0 - 1000000]. exiting."

	exit 1

fi


# check to see how many seconds to wait between vm shutdown checks. messages to user only. if input invalid, exit.
if [[ "$seconds_to_wait" =~ ^[0-9]+$ ]]; then

	if [ "$seconds_to_wait" -lt 30 ]; then

		echo "warning: seconds_to_wait is $seconds_to_wait. this is potentially an insufficient number of seconds to wait between shutdown checks."

	elif [ "$seconds_to_wait" -gt 600 ]; then

		echo "warning: seconds_to_wait is seconds_to_wait. this is a vast number of seconds to wait between shutdown checks."

	elif [ "$seconds_to_wait" -ge 30 -a "$seconds_to_wait" -le 600 ]; then

		echo "information: seconds_to_wait is $seconds_to_wait. this is probably a sufficent number of seconds to wait between shutdown checks."

	fi

else

	echo "failure: seconds_to_wait is $seconds_to_wait. this is not a valid format. expecting a number between [0 - 1000000]. exiting."

	exit 1

fi


echo "information: started attempt to backup "$vms_to_backup" to $backup_location"


# set this to force the for loop to split on new lines and not spaces.
IFS=$'\n'

# remove the trailing slash from backup_location if it exists.
backup_location=${backup_location%/}


# loop through the vms in the list and try and back up thier associated xml configurations and vdisk(s).
for vm in $vms_to_backup

do

	# get a list of the vm names installed on the system.
	vm_exists=$(virsh list --all --name)

	# assume the vm is not going to be backed up until it is found on the system
	skip_vm="y"

	# check to see if the vm exists on the system to backup.
	for vmname in $vm_exists

	do

		# if the vm doesnt match then set the skip flag to y.
		if [ "$vm" == "$vmname" ] ; then

			# set a flag i am going to check later to indicate if i should skip this vm or not.
			skip_vm="n"

			# skips current loop.
			continue

		fi

	done


	# if the skip flag was set in the previous section then we have to exit and move onto the next vm in the list.
	if [ "$skip_vm" == "y" ]; then

		echo "warning: $vm can not be found on the system. skipping vm."

		skip_vm="n"

		# skips current loop.
		continue

	else

		echo "information: $vm can be found on the system. attempting backup."

	fi


	# lets create a directory named after the vm within backup_location to store the backup files.
	if [ ! -d $backup_location/$vm ] ; then

		echo "action: $backup_location/$vm does not exist. creating it."

		# make the directory as it doesnt exist. added -v option to give a confirmation message to command line.
		mkdir -vp $backup_location/$vm

	else

		echo "information: $backup_location/$vm exists. continuing."

	fi


	# see if vdisks should be backed up.
	if [ "$backup_vdisks" -eq 1 ] && [ "$number_of_backups_to_keep" -ne 1 ]; then

		# get the list of the vdisks associated with the vm and address them one by one.
		vdisks=$(virsh domblklist "$vm" --details | grep -v "^$" | grep -v "^Target" | grep -v "\-\-\-\-\-" | awk -F" {2,}" '{print $4}')


		# check for the header in vdisks to see if there are any disks
		if [ "$vdisks" == "Source" ]; then

			echo "warning: there are no vdisk(s) associated with $vm to backup."

		fi


		# get vdisk names to check on current backups
		for disk in $vdisks

		do

			if [ ! "$disk" == "Source" ]; then

				# check to see if disk should be skipped.
				if [[ "$vdisks_to_skip" =~ "$disk" ]]; then
				
					echo "information: $disk for $vm was found in vdisks_to_skip. skipping disk."

					continue

				fi

				# get the filename of the disk without the path.
				new_disk=$(basename $disk)

				# check the extension of the disk to ensure only vdisks are copied.
				# Do not use in conjunction with quemu-img conversion
				if [ ! "${disk##*.}" == "img" ] && [ ! "${disk##*.}" == "qcow2" ]; then

					echo "warning: $disk of $vm is not a vdisk. skipping."

					continue

				fi
				
				# get the most recent vdisk file.
				newest_vdisk_file=$(ls -tp $backup_location/$vm/*.{img,qcow2} | grep -v '/$' | sed -n 1p)

				# check to see if a backup already exists for this vdisk and make a copy of it before shutting down the guest.
				if [ -f "$newest_vdisk_file" ]; then

					cp -av --sparse=always "$newest_vdisk_file" "$backup_location/$vm/$timestamp$new_disk"

					# make sure copy has current date/time for modified attribute so that removing old disks by date will work.
					touch -d "now" "$backup_location/$vm/$timestamp$new_disk"

				fi

				# send a message to the user based on whether there was an actual copy or a dry-run.
				if [ "$actually_copy_files" -eq 0 ]; then

					echo "information: dry-run copy of backup of $new_disk vdisk to $backup_location/$vm/$timestamp$new_disk complete."

				else

					echo "information: copy of backup of $new_disk vdisk to $backup_location/$vm/$timestamp$new_disk complete."

				fi

			fi

		done
	fi


	# get the state of the vm for making sure it is off before backing up.
	vm_state=$(virsh domstate "$vm")

	# get the state of the vm for putting the VM in it's original state after backing up.
	vm_original_state=$vm_state

	# resume the vm if it is suspended, based on testing this should be instant but will trap later if it has not resumed.
	if [ "$vm_state" == "paused" ]; then

		echo "action: $vm is $vm_state. resuming."

		# resume the vm.
		virsh resume "$vm"

	fi


	# if the vm is running try and shut it down.
	if [ "$vm_state" == "running" ]; then

		echo "action: $vm is $vm_state. shutting down."

		# attempt to cleanly shutdown the vm.
		virsh shutdown "$vm"

		echo "information: performing $clean_shutdown_checks $seconds_to_wait second cycles waiting for $vm to shutdown cleanly"

		# the shutdown of the vm may last a while so we are going to check periodically based on global input variables.
		for (( i=1; i<=$clean_shutdown_checks; i++ ))

		do

			echo "information: clycle $i of $clean_shutdown_checks: waiting $seconds_to_wait seconds before checking if the vm has shutdown"

			# wait x seconds based on how many seconds the user wants to wait between checks for a clean shutdown.
			sleep $seconds_to_wait

			# get the state of the vm.
			vm_state=$(virsh domstate "$vm")

			# if the vm is running decide what to do.
			if [ "$vm_state" == "running" ]; then

				echo "information: $vm is $vm_state"

				# if we have already exhausted our wait time set by the script variables then its time to do soemthing else.
				if [ $i = "$clean_shutdown_checks" ] ; then

					# check if the user wants to kill the vm on failure of unclean shutdown.
					if [ "$kill_vm_if_cant_shutdown" -eq 1 ]; then

						echo "action: kill_vm_if_cant_shutdown is $kill_vm_if_cant_shutdown. killing vm."

						# destroy vm, based on testing this should be instant and without failure.
						virsh destroy "$vm"

						# get the state of the vm.
						vm_state=$(virsh domstate "$vm")

						# if the vm is shut off then proceed or give up.
						if [ "$vm_state" == "shut off" ]; then

							# set a flag to check later to indicate whether to backup this vm or not.
							can_backup_vm="y"

							echo "information: $vm is $vm_state. can_backup_vm set to $can_backup_vm"

							break

						else

							# set a flag to check later to indicate whether to backup this vm or not.
							can_backup_vm="n"

							echo "failure: $vm is $vm_state. can_backup_vm set to $can_backup_vm"

						fi

					# if the user doesnt want to force a shutdown then there is nothing more to do so i cannot backup the vm.
					else

						# set a flag to check later to indicate whether to backup this vm or not.
						can_backup_vm="n"

						echo "failure: $vm is $vm_state. can_backup_vm set to $can_backup_vm"

					fi

				fi

			# if the vm is shut off then go onto backing it up.
			elif [ "$vm_state" == "shut off" ]; then

				# set a flag to check later to indicate whether to backup this vm or not.
				can_backup_vm="y"

				echo "information: $vm is $vm_state. can_backup_vm set to $can_backup_vm"

				break

			# if the vm is in a state that is not explicitly defined then do nothing as it is unknown how to handle it.
			else

				# set a flag to check later to indicate whether to backup this vm or not.
				can_backup_vm="n"

				echo "failure: $vm is $vm_state. can_backup_vm set to $can_backup_vm"

			fi

		done


	# if the vm is shut off then go straight onto backing it up.
	elif [ "$vm_state" == "shut off" ]; then

		# set a flag to check later to indicate whether to backup this vm or not.
		can_backup_vm="y"

		echo "information: $vm is $vm_state. can_backup_vm set to $can_backup_vm"


	# if the vm is suspended then something went wrong with the attempt to recover it earlier so do not attempt to backup.
	elif [ "$vm_state" == "suspended" ]; then

		# set a flag to check later to indicate whether to backup this vm or not.
		can_backup_vm="n"

		echo "failure: $vm is $vm_state. can_backup_vm set to $can_backup_vm"


	# if the vm is in a state that has not been explicitly defined then do nothing as it is unknown how to handle it.
	else

		# set a flag to check later to indicate whether to backup this vm or not.
		can_backup_vm="n"

		echo "failure: $vm is $vm_state. can_backup_vm set to $can_backup_vm"

	fi


	# check whether to backup the vm or not.
	if [[ "$can_backup_vm" == "y" ]]; then

		echo "action: can_backup_vm flag is $can_backup_vm. starting backup of $vm xml configuration and vdisk(s)."


		# see if xml should be backed up.
		if [ "$backup_xml" -eq 1 ]; then

			# dump the vm xml configuration locally first.
			virsh dumpxml "$vm" > "$vm.xml"

			echo "action: actually_copy_files is $actually_copy_files."

			# check if only one non-timestamped backup is being kept. if so, perform rsync without a timestamp. if not, continue as normal.
			if [ $timestamp_files -eq 0 ]  && [ "$number_of_backups_to_keep" -eq 1 ]; then
			
				# copy or pretend to copy the xml configuration to the backup location specified by the user.
				rsync -av$rsync_dry_run_option "$vm.xml" "$backup_location/$vm/$vm.xml"

				# make sure copy has current date/time for modified attribute so that removing old disks by date will work.
				touch -d "now" "$backup_location/$vm/$vm.xml"

				# check to see if compare_files is enabled. if yes, check for xml differences.
				if [ "$compare_files" -eq 1 ]; then

					if ! cmp -s "$vm.xml" "$backup_location/$vm/$vm.xml"; then

						echo "warning: xml backup file is different than source file. retrying backup."

						rsync -av$rsync_dry_run_option "$vm.xml" "$backup_location/$vm/$vm.xml"

						# make sure copy has current date/time for modified attribute so that removing old disks by date will work.
						touch -d "now" "$backup_location/$vm/$vm.xml"

						if ! cmp -s "$vm.xml" "$backup_location/$vm/$vm.xml"; then

							echo "warning: xml backup file failed second comparison."

						else

							echo "information: xml backup file passed second comparison. moving on."

						fi

					else

						echo "information: xml backup file matches source file. moving on."

					fi

				fi

			else
			
				# copy or pretend to copy the xml configuration to the backup location specified by the user.
				rsync -av$rsync_dry_run_option "$vm.xml" "$backup_location/$vm/$timestamp$vm.xml"

				# make sure copy has current date/time for modified attribute so that removing old disks by date will work.
				touch -d "now" "$backup_location/$vm/$timestamp$vm.xml"

				# check to see if compare_files is enabled. if yes, check for xml differences.
				if [ "$compare_files" -eq 1 ]; then

					if ! cmp -s "$vm.xml" "$backup_location/$vm/$timestamp$vml.xml"; then

						echo "warning: xml backup file is different than source file. retrying backup."

						rsync -av$rsync_dry_run_option "$vm.xml" "$backup_location/$vm/$timestamp$vm.xml"

						# make sure copy has current date/time for modified attribute so that removing old disks by date will work.
						touch -d "now" "$backup_location/$vm/$timestamp$vm.xml"

						if ! cmp -s "$vm.xml" "$backup_location/$vm/$timestamp$vm.xml"; then

							echo "warning: xml backup file failed second comparison."

						else

							echo "information: xml backup file passed second comparison. moving on."

						fi

					else

						echo "information: xml backup file matches source file. moving on."

					fi

				fi

			fi


			# delete the local copy of the xml configuration.
			rm "$vm.xml"

			# send a message to the user based on whether there was an actual copy or a dry-run.
			if [ "$actually_copy_files" -eq 0 ]; then

				echo "information: dry-run backup of $vm xml configuration to $backup_location/$vm/$timestamp$vm.xml complete."

			else

				echo "information: backup of $vm xml configuration to $backup_location/$vm/$timestamp$vm.xml complete."

			fi
			
		fi


		# see if vdisks should be backed up.
		if [ "$backup_vdisks" -eq 1 ]; then

			# get the list of the vdisks associated with the vm and address them one by one.
			vdisks=$(virsh domblklist "$vm" --details | grep -v "^$" | grep -v "^Target" | grep -v "\-\-\-\-\-" | awk -F" {2,}" '{print $4}')


			# check for the header in vdisks to see if there are any disks
			if [ "$vdisks" == "Source" ]; then

				echo "warning: there are no vdisk(s) associated with $vm to backup."

			fi


			for disk in $vdisks

			do

				if [ ! "$disk" == "Source" ]; then


					# get the filename of the disk without the path.
					new_disk=$(basename $disk)

					# check the extension of the disk to ensure only vdisks are copied.
					# Do not use in conjunction with quemu-img conversion
					if [ ! "${disk##*.}" == "img" ] && [ ! "${disk##*.}" == "qcow2" ]; then

						echo "warning: $disk of $vm is not a vdisk. skipping."

						continue

					fi

					echo "action: actually_copy_files is $actually_copy_files."


					# copy or pretend to copy the vdisk to the backup location specified by the user.
					# check if only one non-timestamped backup is being kept. if so, perform cp -f without a timestamp. if not, continue as normal.
					if [ $timestamp_files -eq 0 ]  && [ "$number_of_backups_to_keep" -eq 1 ]; then

						cp -afv --sparse=always "$disk" "$backup_location/$vm/$new_disk"

						# make sure copy has current date/time for modified attribute so that removing old disks by date will work.
						touch -d "now" "$backup_location/$vm/$new_disk"

						# check to see if compare_files is enabled. if yes, check for vdisk differences.
						if [ "$compare_files" -eq 1 ]; then

							if ! cmp -s "$disk" "$backup_location/$vm/$new_disk"; then

								echo "warning: vdisk backup file is different than source file. attempting slower rsync backup."

								rsync -av$rsync_dry_run_option --sparse "$disk" "$backup_location/$vm/$new_disk"

								# make sure copy has current date/time for modified attribute so that removing old disks by date will work.
								touch -d "now" "$backup_location/$vm/$new_disk"

								if ! cmp -s "$disk" "$backup_location/$vm/$new_disk"; then

									echo "warning: vdisk backup file failed second comparison."

								else

									echo "information: vdisk backup file passed second comparison. moving on."

								fi

							else

								echo "information: vdisk backup file matches source file. moving on."

							fi

						fi

					else

						# check to see if an existing backup was already copied. if so, use rsync. if not, use cp.
						if [ ! -f "$backup_location/$vm/$timestamp$new_disk" ]; then

							cp -av --sparse=always "$disk" "$backup_location/$vm/$timestamp$new_disk"

							# make sure copy has current date/time for modified attribute so that removing old disks by date will work.
							touch -d "now" "$backup_location/$vm/$timestamp$new_disk"

						else

							rsync -av$rsync_dry_run_option --inplace --no-whole-file "$disk" "$backup_location/$vm/$timestamp$new_disk"

							# make sure copy has current date/time for modified attribute so that removing old disks by date will work.
							touch -d "now" "$backup_location/$vm/$timestamp$new_disk"

						fi

						# check to see if compare_files is enabled. if yes, check for vdisk differences.
						if [ "$compare_files" -eq 1 ]; then

							if ! cmp -s "$disk" "$backup_location/$vm/$timestamp$new_disk"; then

								echo "warning: vdisk backup file is different than source file. attempting slower rsync backup."

								rsync -av$rsync_dry_run_option --sparse "$disk" "$backup_location/$vm/$timestamp$new_disk"

								# make sure copy has current date/time for modified attribute so that removing old disks by date will work.
								touch -d "now" "$backup_location/$vm/$timestamp$new_disk"

								if ! cmp -s "$disk" "$backup_location/$vm/$timestamp$new_disk"; then

									echo "warning: vdisk backup file failed second comparison."

								else

									echo "information: vdisk backup file passed second comparison. moving on."

								fi

							else

								echo "information: vdisk backup file matches source file. moving on."

							fi

						fi

					fi

					# send a message to the user based on whether there was an actual copy or a dry-run.
					if [ "$actually_copy_files" -eq 0 ]; then

						echo "information: dry-run backup of $new_disk vdisk to $backup_location/$vm/$timestamp$new_disk complete."

					else

						echo "information: backup of $new_disk vdisk to $backup_location/$vm/$timestamp$new_disk complete."

					fi

				fi

			done

		fi


		# check to see if set_vm_to_original_state is 1 and then check the vm's original state.
		if [ "$set_vm_to_original_state" -eq 1 ]; then
			# start the vm after backup based on previous state.
			if [ "$vm_original_state" == "running" ]; then
				echo "action: vm_original_state is $vm_original_state. starting $vm."

				# start vm
				virsh start "$vm"

			else

				echo "information: vm_original_state is $vm_original_state. not starting $vm."

			fi
		fi


		# if start_vm_after_backup is set to 1 then start the vm but dont check that it has been successfull.
		if [ "$start_vm_after_backup" -eq 1 ]; then

			echo "action: start_vm_after_backup is $start_vm_after_backup. starting $vm."

			# try and start the vm.
			virsh start "$vm"

		fi

		# check to see if backup files should be compressed.
		if [ "$compress_backups" -eq 1 ]; then

			# check if only one non-timestamped backup is being kept. if so, perform compression without a timestamp. if not, continue as normal.
			if [ $timestamp_files -eq 0 ]  && [ "$number_of_backups_to_keep" -eq 1 ]; then

				# make sure new image files exist before removing existing tarball
				if [[ -n $(find "$backup_location/$vm/" -type f \( -name "*.img" -or -name "*.qcow2" \) ) ]]; then

					echo "found new image files. removing existing tarball."

					# remove existing tarball
					rm "$backup_location/$vm/*.tar.gz"

					# create new compressed tarball with latest backup.
					tar zcvSf "$backup_location/$vm/$vm.tar.gz" "$backup_location/$vm/*.{xml,img,qcow2}" && find "$backup_location/$vm/" -type f \( -name "*.xml" -or -name "*.img" -or -name "*.qcow2" \) -exec rm -f {} \;

				else

					echo "warning: could not find new image files. backup may have failed. not removing existing tarball."

				fi

			else

				# create compressed tarball with ALL .xml, .img, and .qcow2 files into one tarball and then remove the source files.
				tar zcvSf "$backup_location/$vm/$timestamp$vm.tar.gz" "$backup_location/$vm/*.{xml,img,qcow2}" && find "$backup_location/$vm/" -type f \( -name "*.xml" -or -name "*.img" -or -name "*.qcow2" \) -exec rm -f {} \;

			fi

		fi

	else

		# start the vm based on previous state.
		if [ "$vm_original_state" == "running" ]; then
			echo "action: vm_original_state is $vm_original_state. starting $vm."

			# start vm
			virsh start "$vm"

		else

			echo "information: vm_original_state is $vm_original_state. not starting $vm."

		fi

		# for whatever reason the backup attempt failed.
		echo "failure: backup of "$vm" to $backup_location/$vm failed."


		# if start_vm_after_failure is set to 1 then start the vm but dont check that it has been successfull.
		if [ "$start_vm_after_failure" -eq 1 ]; then

			echo "action: start_vm_after_failure is $start_vm_after_failure starting $vm."

			# try and start the vm.
			virsh start "$vm"

		fi

	fi


	echo "information: backup of "$vm" to $backup_location/$vm completed."

	# check to see how many days backups should be kept.
	if [ $number_of_days_to_keep_backups -eq 0 ]; then
	
		echo "information: nubmer of days to keep backups set to indefinitely."

	else

		echo "information: cleaning out backups older than $number_of_days_to_keep_backups days in location ONLY if newer files exist in " $backup_location/$vm/

		# create variable equal to number_of_days_to_keep_backups plus one to make sure that there are files younger than the cutoff date.
		days_plus_1=$(($number_of_days_to_keep_backups + 1))

		for j in $backup_location/$vm/

		do

			if [[ -n $(find "$j" -type f \( -name "*.xml" \) -mmin -$(($days_plus_1*24*60))) ]]; then
				
				find "$j" -type f \( -name "*.xml" \) -mmin +$(($number_of_days_to_keep_backups*24*60)) -exec rm -f {} \;

			fi

			if [[ -n $(find "$j" -type f \( -name "*.img" -or -name "*.qcow2" \) -mmin -$(($days_plus_1*24*60))) ]]; then
				
				find "$j" -type f \( -name "*.img" -or -name "*.qcow2" \) -mmin +$(($number_of_days_to_keep_backups*24*60)) -exec rm -f {} \;

			fi

			if [[ -n $(find "$j" -type f \( -name "*.tar.gz" \) -mmin -$(($days_plus_1*24*60))) ]]; then
				
				find "$j" -type f \( -name "*.tar.gz" \) -mmin +$(($number_of_days_to_keep_backups*24*60)) -exec rm -f {} \;

			fi

		done

	fi

	# check to see how many backups should be kept.
	if [ $number_of_backups_to_keep -eq 0 ]; then
	
		echo "information: number of backups to keep set to infinite."

	else

		echo "information: cleaning out backups over $number_of_backups_to_keep in location " $backup_location/$vm/

		# set create variable equal to number_of_backups_to_keep plus one to make sure that the correct number of files are kept.
		backups_plus_1=$(($number_of_backups_to_keep + 1))
		
		# remove xml files that are over the limit.
		ls -tp $backup_location/$vm/*.xml | grep -v '/$' | tail -n +$backups_plus_1 | xargs -d '\n' -r rm --

		# remove image files that are over the limit.
		ls -tp $backup_location/$vm/*.{img,qcow2} | grep -v '/$' | tail -n +$backups_plus_1 | xargs -d '\n' -r rm --

		# remove tar.gz files that are over the limit.
		ls -tp $backup_location/$vm/*.tar.gz | grep -v '/$' | tail -n +$backups_plus_1 | xargs -d '\n' -r rm --

	fi

done

echo "information: finished attempt to backup "$vms_to_backup" to $backup_location."

exit 0


######################################################### script end ###########################################################

# Originally from unraid-autovmbackup by Daniel Jackson (danioj)
# Includes additions for removing old backups added by Deeks

# for original script go to:
# https://lime-technology.com/forum/index.php?topic=47986
# for Deeks script go to:
# https://lime-technology.com/forums/topic/46281-unraid-autovmbackup-automate-backup-of-virtual-machines-in-unraid-v04/?do=findComment&comment=589821
